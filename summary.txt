1.什么是java的三种技术架构
	JAVASE：完成桌面应用程序的开发，是其他两者的基础。
	JAVAEE：开发企业环境下的应用程序，主要针对web程序开发。
	JAVAME：开发电子消费产品和嵌入式设备，如手机中的程序。
2.JDK和JRE有什么区别
	JDK：java development kit，java的开发和运行环境，java的开发工具和jre。
	JRE：java Runtime environment，java程序的运行环境，Java运行的所需类库和VM（java虚拟机）。
3.javac和java命令分别完成什么
	javac：负责的是编译的部分，当执行javac命令时，会启动java的编译器程序，对指定扩展名的 .java文件进行编译，
		生成了jvm可以识别的字节码文件，也就是class文件，也就是java的运行程序。
	java：负责运行的部分，会启动jvm加载运行时所需要的类库，并对class文件进行执行。
4.对两个变量的数据进行互换，但不引入第三方变量
	加减：a = a + b ---- b = a - b ---- a = a - b
	异或：a = a ^ b ---- b = a ^ b ---- a = a ^ b
5.switch 后面的小括号中变量都可以为
	byte char short int
6.数组的表现形式
	int[] a = new int[10]
	int[] a = {1l,22,33}
	int[] a = new int[]{11,22,33}
7.java的内存分布
	寄存器
	本地方法区
	堆（heap）：用于存储数组和对象，也就是实体。所有的对象实例及数组都要在堆上分配。包括成员变量，new出来对象。
		特点：可以被多个线程共享，速度慢，灵活。
	栈（stack）：存放的是局部变量（函数中定义的变量，函数上的参数，语句中的变量）。对于基本的数据类型，
		存放的是变量的值；对于对象变量，存放的是堆内存的地址。
		特点：不可以被多个线程共享，但空间连续，速度快，不灵活。
	方法区（codeSegment）：堆里面的一部分。存放对象的方法（存放已被虚拟机加载的类信息：代码，静态变量，常量池）
		特点：可以被多个线程共享，速度慢，灵活。
8.主函数main的存在，仅为该类是否需要独立运行，如果不需要，主函数可以不用定义。
9.构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作仅进行一次--swing加载界面功能代码都写在construction里面。
10.静态方法只能访问静态成员，不可以访问非静态成员：因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员；静态方法中
	不能使用this，super关键字：因为this代表对象，而静态存在时，有可能没有对象，所以this无法使用。
11.成员变量和静态变量的区别：
	成员变量所属于对象，所以也可称为实例变量 --- 静态变量所属于类，所以称为类变量。
	成员变量在堆内存中 --- 静态变量在方法区中。
	成员变量随着对象创建而存在，对象回收而消失 --- 静态变量随着类的加载而存在，类的消失而消失。
	成员变量只能被对象调用 --- 静态变量可以被对象调用，也可以被类名调用。
	所以：成员变量可以成为对象的特有数据，静态变量成为对象的共享收据。
12.静态代码块 构造代码块 构造函数同时存在时的执行顺序
	静态代码块 ---> 构造代码块 ---> 构造函数
13.单例设计模式：保证一个类在内存中的唯一性。比如多个程序读取一个配置文件时。
	代码体现：私有化构造函数 --- 创建私有并静态的本类对象 --- 定义共有并静态的方法，返回该对象。
	饿汉式：class Single{
		private Single(){}
		private static Single s = new Single();
		public static Single getInstance(){
			return s;
		}
	}
	懒汉式：延迟加载方式
	class Single{
		private Single(){}
		private static Single s = null;
		public static Single getInstance(){
			if(s == null){
				s = new Single();
			}
			return s;
		}
	}
14.super和this
	super()和this()是否可以同时出现在构造函数中：不能，两个语句只能有一个定义在第一行，所以只能出现一个。
	为什么一定要定义在第一行：因为super和this都是调用构造函数，而构造函数用于初始化，所以初始化动作要最先完成。
15.子类覆盖父类时，必须要保证：子类方法的权限必须大于等于父类方法权限才可以实现继承，否则，编译失败。
16.final的特点
	这个关键字是一个修饰符，可以修饰类，方法，变量。
	被final修饰的类是一个最终类，不可以被继承。
	被final修饰的方法是一个最终方法，不可以被覆盖。
	别final修饰的变量是一个常量，只能赋值一次，而且在创建的的时候必须初始化。
17.抽象类abstract的特点
	抽象方法之定义方法声明，并不定义方法实现，无方法体abstract void show（）。
	抽象类不可以被创建对象（实例化） 不能用new关键字。
	抽象类只能被继承。
	抽象类中是否有构造函数：有，用于给子类对象进行初始化。
	抽象类是否可以定义非抽象的方法：可以。
	抽象关键字abstract和那些不可以共存：final private static 。
	抽象类中可不可以不定义抽象犯法：可以，抽象方法的目的仅仅为了不让该类创建对象。
18.接口
	接口中的成员都有固定的修饰符。
		成员变量：public static final
		成员方法：public abstract
	接口中有抽象方法，说明接口不可以被实例化。
	接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化，否则，该子类还是一个抽象类。
	接口可以被多实现，这就是多重继承改良后的结果。
	接口可以多继承接口。
19.模板方法设计模式：
	解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
	abstract class GetTime{
		public final void getTime(){ //此功能如果不需要复写，可加final限定
			long start = System.currentTimeMillis();
			code(); //不确定的功能部分，提取出来，通过抽象方法实现
			long end = System.currentTimeMillis();
			System.out.println("毫秒是："+(end-start));
		}
		public abstract void code(); //抽象不确定的功能，让子类复写实现
	}
	class SubDemo extends GetTime{
		public void code(){ //子类复写功能方法
			for(int y=0; y<1000; y++){
				System.out.println("y");
			}
		}
	}
20.多态
	定义一个父类引用指向一个子类对象既可以使用子类强大的功能，又可以抽取父类的共性。
		父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义但父类中没有到方法，它无法调用。
		父类中的一个方法只有在父类中定义而子类中没有重写才会调用；如果子类重写了，就会去调用子类的方法，这就是动态连接。
	用instanceof<对象 instanceof 类型>判断对象是否实现了指定的接口或者继承了指定的父类。
21.多态在子父类成员上的体现
	成员变量：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。即编译运行都看=左边。
	成员函数：编译看=左边 ，运行看=右边。
	静态函数：编译运行都看=左边。
22.String toString（）：将对象变成字符串，默认返回格式：类名@哈希值 
		= getClass().getName()+'@'+Integer.toHexString(hashCode())
23.异常java.lang.Throwable
	--Error
	--Exception
		--RuntimeException
		--其他的Exception
	异常消息catch (Exception e) { //e用于接收try检测到的异常对象。
			System.out.println("message:"+e.getMessage());//获取的是异常的信息。
			System.out.println("toString:"+e.toString());//获取的是异常的名字+异常的信息。
			e.printStackTrace();//打印异常在堆栈中信息；异常名称+异常信息+异常的位置。
		}
	throw和throws的区别
		throw用于抛出异常对象，后面跟的是异常对象，throw用在函数内。
		throws用于抛出异常类，后面跟的是异常类名，可以跟多个，用逗号隔开，throws用在函数上。
	定义异常处理时，什么时候定义try，什么时候定义throws呢
		功能内部如果出现异常，如果内部可以处理，就用try,如果功能内部处理不了，就必须声明出来，让调用者处理。
24.java常用的软件包
	如果导入的两个软件包中存在着相同名称的类，这时如果用到该类，必须在代码中指定包名。
	java.lang：language java的核心包。
	java.awt：定义的都是用于java图形界面开发的对象。
	java.swing：提供所有的windows桌面应用程序包括的组件，Frame，Table。
	java.net：定义java网络编程方面的对象。
	java.io：input output用于操作设备上数据的对象都在该包中。
	java.util ：java的工具包，时间对象，集合框架。
	java.applet：application+let客户端Java小程序。
25.线程
	返回当前线程的名称：Thread.currentThread().getName()。
	start()方法，启动了线程，并让jvm调用了run方法。
	创建线程的第一种方式：继承Thread ，由子类复写run方法。
		步骤：
		1）定义类继承Thread类。
		2）目的是复写run方法，将要让线程运行的代码都存储到run方法中。
		3）通过创建Thread类的子类对象，创建线程对象。
		4）调用线程的start方法，开启线程，并执行run方法。
		调用方法：Person person = new Person() --> person.start()。
	创建线程的第二种方式：实现一个接口Runnable。
		步骤：
		1）定义类实现Runnable接口。
		2）覆盖接口中的run方法（用于封装线程要运行的代码）。
		3）通过Thread类创建线程对象；
		4）将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。
		为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。
		5）调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。
			Ticket t = new Ticket();
			Thread t1 = new Thread(t); //创建线程。
			t1.start();
	为什么要有Runnable接口的出现
		因为实现Runnable接口可以避免单继承的局限性。
		Runnable接口将线程线程要执行的任务封装成了对象。
	多线程安全问题的解决方法：就是同步代码块。
		格式：
		synchronized(对象) {  // 任意对象都可以。这个对象就是锁。
			需要被同步的代码；
		}
26.关于同步
	等待唤醒机制涉及的方法：
		wait：将同步中的线程处于冻结状态，释放了执行权，释放了资格，同时将线程对象存储到线程池中。
		notify:唤醒线程池中某一个等待的线程。
		notifyAll：唤醒的是线程池中的所有线程。
	上面这些方法都需要定义在同步块中。
		wait和sleep的区别
		wait：可以指定时间也可以不指定时间，不指定时间时，只能由对应的notify或notifyAll来唤醒。
		sleep：必须指定时间，时间到自动从冻结状态转成运行状态（临时阻塞状态）。
		wait：线程会释放执行权，而且线程会释放锁。
		sleep：线程会释放执行权，但不会释放锁。
	线程的停止
		定义循环的结束标记。
		如果线程处于冻结状态，是不可能读到标记的，这是就需要通过线程Thread类中的interrupt方法，将其冻结状态强行解除，
			让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。
	Thread常用方法
		getPriority（）：返回线程的优先级。
		toString（）：返回该线程的字符串表示形式，包括线程名称，优先级和线程组。
		Thread.yield（）：暂停当前正在执行的线程对象，并执行其他线程。
		join（）：临时加入一个线程，当A线程执行到了B线程的join方式，A线程处于冻结状态，释放执行权，B开始执行；
			A什么时候执行呢，当B线程运行结束后，A才从冻结状态恢复到运行状态执行。
27.Lock接口
	同步synchronized是隐式的锁操作，而Lock对象是显示的锁操作。
	Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到一个对象中，这个对象就是Condition。
		将Object中的三个方法进行单独的封装，并提供了功能一致的方法：await（），signal（），signalAll（）。
28.String<java.lang>
	字符串一旦被初始化，就不可以被改变，存放在方法区中的常量池中。	